# Project Planning: OFF to OpenMM

## 1. Vision

Our vision is to empower computational chemistry researchers by providing a seamless and automated workflow for using custom force fields, specifically those generated by the Adaptive Force Matching (AFM) method, within the OpenMM simulation ecosystem. We aim to eliminate the tedious and error-prone manual steps currently required, thereby accelerating research and expanding the user base of the AFM method.

This project will deliver a robust and user-friendly suite of command-line tools that bridge the gap between force field generation (CRYOFF `.off` files) and simulation (OpenMM `.xml` and `.pdb` files).

## 2. Architecture

The application will be composed of two distinct, single-purpose command-line tools, ensuring a modular and maintainable design.

### Tool 1: Force Field Converter (`off_to_openmm.py`) ✅ COMPLETED

*   **Input:** `-off` file path, `-output` path, optional `-molnames` and `-charges` flags
*   **Implemented Architecture:**
    1.  **OffFileParser Class:** Complete direct .off file parsing
        ✅ Handles format variations: `[MOLTYP]`/`[MOL]`, `[ATOMS]`/`[ATOM]`, etc.
        ✅ Extracts molecule definitions per section with special atom handling (4*, NETF, TORQ, M, MMM)
        ✅ Parses bonded interactions: BONDS, ANGLES, DIHEDRAL sections
        ✅ Parses nonbonded interactions: COU, EXP, SRD sections
        ✅ Extracts `#define` parameter statements for force constants
    
    2.  **Multi-Molecule Support System:**
        ✅ Supports multiple molecule types in single .off file
        ✅ Selective inclusion via `-molnames` flag (comma-separated)
        ✅ Unique atom naming across all molecules (C0, C1, H0, H1)
        ✅ Handles diverse molecular systems (organics, solvated systems)
    
    3.  **Charge Integration System:**
        ✅ Reads external charge files via `-charges` flag
        ✅ Format: "AtomType Charge" (e.g., "HW 0.6645")
        ✅ Integrates charges into NonbondedForce section (NOT Residues)
    
    4.  **Complete OpenMM XML Generation:**
        ✅ AtomTypes section with element extraction and mass assignment
        ✅ Residues section with unique naming and bond connectivity (no charges)
        ✅ NonbondedForce section with charges (sigma=0.0, epsilon=0.0, scales=1.0)
        ✅ HarmonicBondForce with unit-converted parameters
        ✅ HarmonicAngleForce with degree-to-radian conversion
        ✅ PeriodicTorsionForce with phase conversion and periodicities
        ✅ CustomNonbondedForce for EXP interactions (exponential repulsion)
        ✅ CustomNonbondedForce for SRD interactions (multiple powers, dispersion)
        ✅ Proper ForceField XML wrapper structure

*   **Output:** Complete, valid OpenMM `.xml` force field file ready for simulations

### Tool 2: PDB Preprocessor (`pdb_preprocessor.py`)

*   **Input:** A `.pdb` file path provided as a command-line argument.
*   **Core Logic:**
    1.  **PDB Parser:** Reads the `ATOM` and `HETATM` records from the input PDB file.
    2.  **Connectivity Calculator:** This is the core of the tool. It will read the completed .xml force field file to understand connectivity in each molecule.
    3.  **CONECT Record Generator:** Based on the calculated bonds, this module will generate the `CONECT` records in the standard PDB format.
    4.  **File Writer:** Appends the generated `CONECT` records to the original PDB content and writes the result to a new output file.
*   **Output:** A new `.pdb` file containing the original atomic coordinates plus the appended bonding information.

## 3. Technology Stack

*   **Programming Language:** Python 3.9+
*   **Core Libraries (Standard Library):**
    *   `argparse`: For creating a user-friendly command-line interface (CLI).
    *   `xml.etree.ElementTree`: For robust and safe generation of the `.xml` force field file.
*   **External Libraries (to be installed via pip):**
    *   `pytest`: For implementing a comprehensive suite of unit and integration tests.
*   **Code Style and Linting:**
    *   `black`: For automated, consistent code formatting.
    *   `ruff`: For fast and effective linting to catch errors and enforce best practices.

## 4. Required Tools & Environment

*   **Version Control:** `git` for tracking changes and collaboration.
*   **Python Environment:** A virtual environment (e.g., using `venv`) to manage project dependencies.
*   **Terminal:** A standard command-line terminal for running scripts and managing the project.
